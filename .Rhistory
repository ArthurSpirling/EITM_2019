source('~/GitHub/EITM_2019/day2_sophistication_style.R')
word_vectors
source('~/GitHub/EITM_2019/day2_sophistication_style.R')
rm(list=ls())
require(devtools)
#note to self: odd install error for glue and backport, solved by installing
# directly
require(quanteda)
require(readtext)
require(stylest)
rt <- readtext("house_bills/*")
my.corpus <- corpus(rt)
setwd("~/GitHub/EITM_2019")
rm(list=ls())
require(devtools)
#note to self: odd install error for glue and backport, solved by installing
# directly
require(quanteda)
require(readtext)
require(stylest)
rt <- readtext("house_bills/*")
my.corpus <- corpus(rt)
source('~/GitHub/EITM_2019/day2_sophistication_style.R')
require(sophistication)
#lets look up how common "husbandry" is
print(covars_make_baselines("husbandry", baseline_year=2000))
#note that min_ and mean_ are same bec it's just doing a lookup of one word
# can compare to something more common:
print(covars_make_baselines("husband", baseline_year=2000))
#can access matrix of aggregated counts by decade if required.
# for example, let's get the counts of "husbandry"
husbandry.counts <- data_matrix_google1grams[which(rownames(data_matrix_google1grams)=="husbandry"),]
#and for "the"
the.counts <- data_matrix_google1grams[which(rownames(data_matrix_google1grams)=="the"),]
print(husbandry.counts/the.counts) #this is as above for covars_make_baselines
pred
install.packages("text2vec")
library(stringr)  # manipulate strings
library(text2vec)  # GloVe package
word_vectors <- readRDS("https://www.dropbox.com/sh/zb3sxdrkvxyasuo/AAAhSlxOU-RSAhGXtg6fn2C3a?dl=0")
word_vectors <- readRDS("https://www.dropbox.com/sh/zb3sxdrkvxyasuo/AAAhSlxOU-RSAhGXtg6fn2C3a?dl=0.rds")
word_vectors <- readRDS("C:/Users/as9934/Dropbox/EITM_2019_data/glove.rds")
# nearest neighbors function ---
#' Return nearest neighbors based on cosine similarity
#'
#' @param embeds matrix of embeddings
#' @param cue cue word for which cosine distances will be computed
#' @param N number of nearest neighbors to return
#' @param norm character = c("l2", "none") - how to scale input matrices. If they already scaled - use "none" (see ?sim2)
#' @return a character vector of nearest neighbors to cue word
#' @export
# required packages: text2vec, stringr
nearest_neighbors <- function(cue, embeds, N = 5, norm = "l2"){
cos_sim <- sim2(x = embeds, y = embeds[cue, , drop = FALSE], method = "cosine", norm = norm)
nn <- cos_sim <- cos_sim[order(-cos_sim),]
return(names(nn)[2:(N + 1)])  # cue is always the nearest neighbor hence dropped
}
# example ---
nearest_neighbors("welfare", embeds = word_vectors, N = 5, norm = "l2")
